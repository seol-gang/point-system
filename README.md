# Point Service API Server

## 개요

* 포인트 서비스를 구현한 API 서버 입니다.
* 유저의 포인트를 조회, 충전, 사용에 대한 기능을 제공합니다.

## 기능

* 유저의 포인트 조회
* 유저의 포인트 충전
* 유저의 포인트 조회
* 유저의 포인트 충전 및 조회에 대한 히스토리 조회

## 정책

* 유저는 포인트 충전 시 최소 1000 포인트 이상 충전 해야합니다.
* 유저는 포인트를 최대 100만 포인트까지 소지 할 수 있습니다.
* 유저는 포인트를 사용 시 최소 1000 포인트 이상 사용 해야합니다.

## API 명세

* `GET /point` : 포인트 조회
* `GET /point/histories` : 포인트 충전 및 조회 히스토리 조회
* `PATCH /point/:userId/charge` : 포인트 충전
* `PATCH /point/:userId/use` : 포인트 사용

## 프로젝트 구조

```markdown
src/
├── main/
│   └── kotlin/
│       └── io/
│           └── hhplus/
│               └── tdd/
│                   ├── point/
│                   │   ├── controller/                  # 컨트롤러
│                   │   │   └── PointController.kt
│                   │   ├── service/                     # 서비스
│                   │   │   └── PointService.kt
│                   │   └── dto/
│                   │       ├── response/                # 응답 DTO
│                   │       │   └── UserPointResponse.kt
│                   │       └── entities/                # 엔티티 DTO
│                   │           ├── UserPoint.kt
│                   │           └── PointHistory.kt
│                   ├── ApiControllerAdvice.kt
│                   ├── TddApplication.kt
│                   └── database/                        # Mock DB
│                       ├── PointHistoryTable.kt
│                       └── UserPointTable.kt
└── test/
    └── kotlin/
        └── io/
            └── hhplus/
                └── tdd/
                    └── point/
                        ├── e2e
                        │   └── PointController.e2e.test.kt             # E2E 테스트
                        ├── integration/
                        │    ├── PointService.test.kt                   # 서비스 통합 테스트
                        │    └── PointServiceConcurrencyTest.test.kt    # 서비스 동시성 통합 테스트
                        └── unit/
                             └── PointPolicy.test.kt                    # 포인트 정책 단위 테스트

```

## 현재 프로젝트의 동시성 문제 분석

### 문제 상황
* 현재 프로젝트에서 발생할 수 있는 동시성 문제는 아래 예시와 같습니다.

```markdown
ex_1)
1. 유저 A가 포인트를 현재 3000 포인트를 가지고 있습니다.
2. 유저 A가 포인트 3000 포인트를 사용 하려고 합니다.
3. 이때 유저 A가 어떠한 이유로 인해 동시에 2개의 요청을 보냈습니다.
4. 서버에서는 동시에 같은 자원에 접근하여 각 요청에서 3000 포인트를 가지고 있는 것으로 인식하고 포인트를 사용합니다.
5. 결과 적으로 유저는 총 6000 포인트를 사용하게 되는 문제가 발생합니다.

ex_2)
1. 유저 A가 포인트 최대 포인트 한도인 100만 포인트를 충전 하려고 합니다.
2. 이때 유저 A가 어떠한 이유로 인해 동시에 2개의 요청을 보냈습니다.
3. 서버에서는 동시에 같은 자원에 접근하여 각 요청에서 100만 포인트를 충전하는 것으로 인식하고 포인트를 충전합니다.
4. 결과 적으로 유저는 총 200만 포인트를 충전하게 되는 문제가 발생합니다.
```

### 문제 원인
* database의 구현 되어 있는 부분에서 CUD 작업 부분에 랜덤 값으로 실행을 지연 시키고 있습니다.
  

* 이로 인해 포인트 조회와 업데이트 사이의 시간 간격으로 인해 데이터 정합성이 깨질 수 있습니다.
  * 위의 예시로도 적혀져 있지만 좀 더 자세히 설명 하자면 아래와 같습니다.
  * 예시: 포인트 사용 시나리오
    1. 첫 번째 요청이 포인트를 조회 (200ms 소요)
    2. 동시에 두 번째 요청도 포인트를 조회 (200ms 소요)
    3. 두 요청 모두 동일한 포인트 잔액을 확인
    4. 각각 업데이트 작업 수행 (300ms 소요)
    5. 결과적으로 하나의 잔액에서 두 번의 차감이 발생

### 해결 방안
* 현재 구현 되어 있는 database 로는 Transactional 과 Lock을 사용하기 어려울 것으로 판단 됩니다.
  * 실제 DB를 사용 하는 것이 아니기 때문입니다.


* 따라서 문제를 해결 할 2가지 안을 선정 하였습니다.
  * ReentrantLock을 사용하여 code base의 custom lock 을 구현하여 사용
  * Synchronized 어노테이션 사용


* 각각의 사용 방법에 대한 장단점은 다음과 같습니다.
```markdown
* ReentrantLock
  * 장점
    * 락을 거는 시점과 해제 시점을 코드로 제어 가능
    * 타임 아웃 설정이 가능
    * 락의 정책 제어 가능
      * ReentrantLock의 생성자의 매개변수를 통해 제어 가능
        * 오래된 순서대로 락 처리
        * 무작위 순서로 락 처리  
  * 단점
    * 구현 난이도가 높음
    * 락 코드 관리 비용이 생김
    * 버그나 실수로 락 해제가 되지 않아 데드락이 발생할 수 있음

* Synchronized
  * 장점
    * 구현 난이도가 낮음
    * JVM 에서 관리 되기 때문에 관리 비용이 적음
  * 단점
    * 세밀하게 락의 제어가 불가능
    * 사용되는 메서드의 락이 걸리기 때문에 많은 요청시 성능 저하가 발생할 수 있음
      * 또한 요청이 순차 처리 되기 때문에 병목 현상이 발생 할 수 있음
```

## 해결 방법

* 동시성 문제를 해결하기 위해 Synchronized 어노테이션을 사용하여 문제를 해결 하였습니다.


* 이유
  * 현재 프로젝트는 구현 단계라고 생각 하여 병목 현상에 대한 이슈는 크게 없다고 판단하여 선정했습니다.
  * 코드 단위로 커스텀 락을 구현하여 이에 대한 관리 비용을 발생하는 것은 현재 프로젝트에서 오버 엔지니어링이 될 것 같다고 생각 하였습니다.